<!DOCTYPE html>
<html lang='ko'>
<head>
<meta charset="UTF-8">
<meta name="title" content="WebGL - Mouse Drag" />
<meta name="subject" content="WebGL,Transformation,Scale,Matrix,Vector,Mouse Drag" />
<meta name="keywords" content="WebGL,Shader,Transformation,Scale,Matrix,Vector,Mouse Drag" />
<title>WebGL - Mouse Drag</title>
</head>
<body>
<div id='propertyContainer'>
	<label for='polygonN'>N각형 : </label><input class='slider' id='polygonN' type='range' min='3' max='16' value='3'><span id='polyN'>3</span>
	<br/>
	<br/>
	<div>Canvas 위를 마우스로 드래그 해보세요</div>
</div>
<br/>
<canvas id="webgl-canvas" style="border: none;" width="800" height="400"></canvas>
<hr/>
<footer>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><a xmlns:cc="http://creativecommons.org/ns#" href="https://www.facebook.com/hanmomhanda" property="cc:attributionName" rel="cc:attributionURL" target='_blank'>hanmomhanda</a>의 저작물인 이 저작물은(는) <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target='_blank'>크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 4.0 국제 라이선스</a>에 따라 이용할 수 있습니다.<br />
  <hr/>
  <!-- DISCUS -->
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'hanmomhanda'; // required: replace example with your forum shortname
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <!-- DISCUS -->
</footer>
<script id="shader-fs" type="x-shader/x-fragment">
void main(void) {
	gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}
</script>
<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;

uniform vec3 uViewportSizeInPixel;

mat4 pixelUnitEnablerMatrix(vec3 vp) {
	return mat4(
		2.0/vp[0], 0, 0, 0,
		0, 2.0/vp[1], 0, 0,
		0, 0, 2.0/vp[2], 0,
		0, 0, 0, 1
	);
}

uniform vec3 uTranslation;

mat4 translationMatrix(vec3 t) {
	return mat4(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		t[0], t[1], t[2], 1
	);
}

void main(void) {
	gl_Position = pixelUnitEnablerMatrix(uViewportSizeInPixel)
					*translationMatrix(uTranslation)
					*vec4(aVertexPosition, 1.0);
}
</script>
<script>
;(function() {
	var drawWebGL = function(x, y) {
		var canvas, gl, shaderProgram,
			tX, tY, tZ
		;
		canvas = document.getElementById("webgl-canvas"),
		gl = getWebGLContext(canvas),
		initViewport(gl, canvas),
		shaderProgram = getShaderProgram(gl, getShader(gl, "shader-vs"), getShader(gl, "shader-fs")),
		tX = x,
		tY = y,
		tZ = 0,
		pN = parseFloat(document.getElementById('polygonN').value),
		draw(gl, createRegularPolygon(gl, pN),
			[gl.drawingBufferWidth, gl.drawingBufferHeight, 0],
			[tX, tY, tZ],
			shaderProgram
		);
	},

	getWebGLContext = function(canvas) {
		var gl, msg = "Your browser does not support WebGL, or it is not enabled by default.";
		try {
			gl = canvas.getContext("experimental-webgl");
		} catch (e) {
			msg = "Error creating WebGL Context!: " + e.toString();
		}

		if (!gl) {
			alert(msg);
			throw new Error(msg);
		}

		return gl;
	},

	initViewport = function(gl, canvas) {
		gl.viewport(0, 0, canvas.width, canvas.height),
		gl.clearColor(0.3, 0.3, 0.3, 1.0),
		gl.clear(gl.COLOR_BUFFER_BIT);
	},

	createRegularPolygon = function(gl, pN) {
		var vertexBuffer = gl.createBuffer(),
			indexBuffer = gl.createBuffer(),
			aPoint, coreHeight = 100, i,
			vertSize = 3,
			_PI = Math.PI, _RAD = _PI/180, angle = 2*_PI/pN,
			polygon,
			c = Math.cos, s = Math.sin,
			vert = [
				 0.0,  coreHeight,  0.0
			],
			indices = [];

			for( i = 0 ; i < pN - 1 ; i = i/vertSize + 1 ) {
				vert.push(
					( vert[i*=3]*c(angle) + vert[++i]*(-1)*s(angle) ),
					( vert[--i]*s(angle) + vert[++i]*c(angle) ),
					( vert[--i+2] )
				);
			}
			for ( i = 0 ; i < pN -2 ; i++ ) {
				indices.push( 0, i+1, i+2 );
			}
			polygon = {
				vertexBuffer : vertexBuffer,
				indexBuffer : indexBuffer,
				vertSize : vertSize,
				nVerts : pN,
				indexLength : indices.length
			};
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer),
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vert), gl.STATIC_DRAW);

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer),
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

		return polygon;
	},

	getShader = function(gl, id) {
		var shaderScript = document.getElementById(id),
			shader;

		if (!shaderScript) {
			return null;
		}

		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, shaderScript.textContent);
		gl.compileShader(shader);

		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert(gl.getShaderInfoLog(shader));
			return null;
		}

		return shader;
	},

	getShaderProgram = function(gl, vShader, fShader) {
		var shaderProgram = gl.createProgram();

		gl.attachShader(shaderProgram, vShader);
		gl.attachShader(shaderProgram, fShader);
		gl.linkProgram(shaderProgram);

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
			gl.deleteProgram(shaderProgram);
			gl.deleteProgram(vertexShader);
			gl.deleteProgram(fragmentShader);
			return null;
		}

		return shaderProgram;
	},

	draw = function(gl, objToDraw, viewportSizeArray,
					translationArray, shaderProgram) {

		gl.useProgram(shaderProgram);

		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
		gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		gl.bindBuffer(gl.ARRAY_BUFFER, objToDraw.vertexBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, objToDraw.vertSize, gl.FLOAT, false, 0, 0);

		shaderProgram.viewportSizeUniform = gl.getUniformLocation(shaderProgram, "uViewportSizeInPixel");
		gl.uniform3fv(shaderProgram.viewportSizeUniform, viewportSizeArray);

		shaderProgram.translationUniform = gl.getUniformLocation(shaderProgram, "uTranslation");
		gl.uniform3fv(shaderProgram.translationUniform, translationArray);

		if (objToDraw.indexBuffer)
			gl.drawElements(gl.TRIANGLES, objToDraw.indexLength, gl.UNSIGNED_SHORT, 0);
		else
			gl.drawArrays(objToDraw.primtype, 0, objToDraw.nVerts);
	};

	(function (){
		var canvas = document.getElementById("webgl-canvas"),
			canvasB = canvas.getBoundingClientRect(),
			x, y,
			mousedown;

		Array.prototype.slice.call(document.querySelectorAll('.slider'))
			.forEach( function( element ) {
				element.addEventListener('input', function() {
					drawWebGL(x, y);
					element.nextSibling.innerText = element.value;
				});
			});

		canvas.addEventListener('mousedown', function(e) {
			mousedown = true;
		}),

		canvas.addEventListener('mouseup', function(e) {
			mousedown = false;
		}),

		canvas.addEventListener('mousemove', function(e) {
			if (mousedown) {
				x = e.clientX - canvasB.left - canvasB.width/2,
				y = canvasB.height/2 - (e.clientY - canvasB.top),
				drawWebGL(x, y);
			}
		});

		drawWebGL(0, 0);
	})();
})();
</script>
</body>
</html>
